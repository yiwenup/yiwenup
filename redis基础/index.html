<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=X-UA-Compatible content="IE=edge, chrome=1"><title>01_Redis 基础 - Yiwenup - 持续沉淀</title><meta name=Description content="Yiwenup - 持续沉淀"><meta property="og:title" content="01_Redis 基础">
<meta property="og:description" content="一、为什么使用缓存 高性能：缓存可以提升系统性能，通过缓存一些元数据、不会频繁发生改变的数据，在访问数据库查询数据之前提前将数据从缓存中查询出"><meta property="og:type" content="article"><meta property="og:url" content="http://www.yiwenup.cloud/redis%E5%9F%BA%E7%A1%80/"><meta property="og:image" content="http://www.yiwenup.cloud/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-12T19:12:32+08:00"><meta property="article:modified_time" content="2022-01-12T19:12:32+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://www.yiwenup.cloud/logo.png"><meta name=twitter:title content="01_Redis 基础"><meta name=twitter:description content="一、为什么使用缓存 高性能：缓存可以提升系统性能，通过缓存一些元数据、不会频繁发生改变的数据，在访问数据库查询数据之前提前将数据从缓存中查询出"><meta name=application-name content="Yiwenup - 持续沉淀"><meta name=apple-mobile-web-app-title content="Yiwenup - 持续沉淀"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://www.yiwenup.cloud/redis%E5%9F%BA%E7%A1%80/><link rel=prev href=http://www.yiwenup.cloud/branch-helper-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/><link rel=next href=http://www.yiwenup.cloud/redis%E9%AB%98%E5%8F%AF%E7%94%A8/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"01_Redis 基础","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/www.yiwenup.cloud\/redis%E5%9F%BA%E7%A1%80\/"},"image":["http:\/\/www.yiwenup.cloud\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"缓存, 中间件, 分布式系统","wordcount":2876,"url":"http:\/\/www.yiwenup.cloud\/redis%E5%9F%BA%E7%A1%80\/","datePublished":"2022-01-12T19:12:32+08:00","dateModified":"2022-01-12T19:12:32+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":{"@type":"ImageObject","url":"http:\/\/www.yiwenup.cloud\/images\/avatar.png","width":320,"height":320}},"author":{"@type":"Person","name":"yiwenup"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Yiwenup - 持续沉淀"><span class=header-title-pre><i class='fas fa-piggy-bank'></i></span> Yiwen Up <span class=header-title-post><i class='fas fa-leaf'></i></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/categories/><i class='fas fa-folder-open'></i> 分类 </a><a class=menu-item href=/tags/><i class='fas fa-tags fa-fw'></i> 标签 </a><a class=menu-item href=/posts/><i class='fas fa-book'></i> 所有文章 </a><a class=menu-item href=/></a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Yiwenup - 持续沉淀"><span class=header-title-pre><i class='fas fa-piggy-bank'></i></span> Yiwen Up <span class=header-title-post><i class='fas fa-leaf'></i></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/categories/ title><i class='fas fa-folder-open'></i>分类</a><a class=menu-item href=/tags/ title><i class='fas fa-tags fa-fw'></i>标签</a><a class=menu-item href=/posts/ title><i class='fas fa-book'></i>所有文章</a><a class=menu-item href=/ title></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">01_Redis 基础</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-feather-alt"></i></a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/redis/><i class="far fa-folder fa-fw"></i>Redis</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-01-12>2022-01-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 2876 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 6 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#一为什么使用缓存>一、为什么使用缓存</a></li><li><a href=#二redis-的数据类型以及使用场景>二、Redis 的数据类型以及使用场景</a></li><li><a href=#三redis-过期策略>三、Redis 过期策略</a><ul><li><a href=#1-设置过期时间>1. 设置过期时间</a></li><li><a href=#2-内存淘汰机制>2. 内存淘汰机制</a></li></ul></li><li><a href=#四redis-内存模型>四、Redis 内存模型</a></li><li><a href=#五reids-为什么快>五、Reids 为什么快</a></li><li><a href=#六手写-lru-算法>六、手写 LRU 算法</a></li><li><a href=#七redis-持久化>七、Redis 持久化</a><ul><li><a href=#1-rbd>1. RBD</a></li><li><a href=#2-aof>2. AOF</a></li><li><a href=#3-备份和恢复策略>3. 备份和恢复策略</a></li></ul></li><li><a href=#八使用缓存会出现的问题>八、使用缓存会出现的问题</a><ul><li><a href=#1-缓存经典三大场景>1. 缓存经典三大场景</a></li><li><a href=#2-双写一致性问题>2. 双写一致性问题</a></li><li><a href=#3-redis-并发竞争问题>3. Redis 并发竞争问题</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=一为什么使用缓存>一、为什么使用缓存</h2><ul><li>高性能：缓存可以提升系统性能，通过缓存一些元数据、不会频繁发生改变的数据，在访问数据库查询数据之前提前将数据从缓存中查询出来，可以提高响应速度。</li><li>高并发：缓存可以在高峰期之前对热点数据进行提前预热，将他们载入缓存，以便在高峰期能够支撑更大的请求并发。</li></ul><h2 id=二redis-的数据类型以及使用场景>二、Redis 的数据类型以及使用场景</h2><ul><li>string：短信验证码</li><li>hash：缓存分组数据，比如字典项、元数据等</li><li>set：可以基于 set 的特性做类似微博共同粉丝的查找</li><li>list：可以做队列，比如微博的粉丝列表</li><li>zset：排行榜</li></ul><h2 id=三redis-过期策略>三、Redis 过期策略</h2><h3 id=1-设置过期时间>1. 设置过期时间</h3><ul><li>定期删除：Redis 会每隔一段时间随机取 key 进行检查，如果当前的 key 是过期 key，则执行定期删除</li><li>惰性删除：当客户端主动查询某个 key，而这个 key 是过期 key，则会执行惰性删除。<strong>惰性删除对定期删除的随机性导致的过期 key 删除不及时做了补充删除。</strong></li></ul><h3 id=2-内存淘汰机制>2. 内存淘汰机制</h3><blockquote><p>内存淘汰机制在 Redis 可用内存空间不足时生效，会执行既定的<strong>淘汰策略</strong>，同时也是对惰性删除遗留的数据做了进一步的补充删除。</p></blockquote><ul><li>noeviction：当内存不足时，写数据将报错</li><li>allkeys-lru：当内存不足时，移除最近最少使用的 key</li><li>allkeys-random：当内存不足时，随机移除 key</li><li>volatile-lru：当内存不足时，移除最近最少使用的 key（设置了过期时间的）</li><li>volatile-random：当内存不足时，随机移除 key（设置了过期时间的）</li><li>volatile-ttl：当内存不足时，移除设置了过期时间的 key 中，最早过期的</li></ul><p><strong>内存淘汰策略如何选择？为什么吗？</strong></p><p>一般使用<code>allkeys-lru</code>，首先当内存快要满的时候，还是得尽量保证 redis 是可以继续工作的，所以对于策略<code>noeviction</code>来说不可取，其次因为对于随机移除 key 的方式，不安全，可能会随机移除某些热点 key，导致缓存击穿或者缓存雪崩，所以可以排除策略<code>allkeys-random</code>以及<code>volatile-random</code>，接着继续分析<code>allkeys-lru</code>、<code>volatile-lru</code>以及<code>volatile-ttl</code>，既然是需要移除最近最少使用的 key，所以已经无所谓过期时间了，移除的范围是可以尽量大的。</p><h2 id=四redis-内存模型>四、Redis 内存模型</h2><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/image-20220324214403890.png data-srcset="../images/image-20220324214403890.png, ../images/image-20220324214403890.png 1.5x, ../images/image-20220324214403890.png 2x" data-sizes=auto alt=../images/image-20220324214403890.png title=image-20220324214403890></p><h2 id=五reids-为什么快>五、Reids 为什么快</h2><ul><li>Redis 是采用基于 Reactor 模型的、非阻塞 I/O 多路复用机制</li><li>Redis 基于内存进行数据访问</li><li>Redis 是单线程的，避免了多线程上下文频繁切换的开销</li></ul><h2 id=六手写-lru-算法>六、手写 LRU 算法</h2><blockquote><p>以下思路采用基于 Java 原生数据结构 LinkedHashMap 进行实现</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>LRUCache</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>LinkedHashMap</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 缓存大小
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>cacheSize</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 构造器初始化缓存
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>LRUCache</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>cacheSize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 设置HasMap的初始大小，最后一个参数目的是让Map按访问顺序进行排序，最近访问的放在前面，最之前访问的放在最后</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>super</span><span class=p>((</span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=n>Math</span><span class=p>.</span><span class=na>ceil</span><span class=p>(</span><span class=n>cacheSize</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>75</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>),</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>75F</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>cacheSize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>cacheSize</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>protected</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>removeEldestEntry</span><span class=p>(</span><span class=n>Map</span><span class=p>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>eldest</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 当Map中的数据量大于缓存阈值时，则自动删除最之前的的数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=na>size</span><span class=p>()</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>cacheSize</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=七redis-持久化>七、Redis 持久化</h2><blockquote><p>Redis 有两种持久化策略：RDB 和 AOF</p><p>Redis 的持久化策略是缓存数据备份以及灾难恢复的利器</p><p>RBD 和 AOF 两者同时开启将会优先使用 AOF 策略</p></blockquote><h3 id=1-rbd>1. RBD</h3><p>RDB 持久化策略，每隔一段时间生成一份缓存数据快照，每份快照都是独立的文件</p><ul><li>优点<ul><li>对 Redis 读写服务的影响小</li><li>灾难恢复速度快</li></ul></li><li>缺点<ul><li>数据丢失会更多一些，比如在两次生成快照的间隙，Redis 宕机了，那么这段时间的数据就丢失了</li><li>Reids 基于 fork 子进程进行的缓存数据快照，如果当前待生成 RDB 文件很大的话，会导致 client 客户端卡顿</li></ul></li></ul><h3 id=2-aof>2. AOF</h3><p>AOF 持久化策略会记录 Redis 的每一条写命令，将其持久化到文件中，始终是一个文件</p><p><strong>AOF 写文件实际上并不会直接将数据写磁盘文件，而是会先写入 os cache 中，之后 redis 会每隔一段时间执行 os fsync 将其强制刷入磁盘文件，使用 os cache 作为缓冲区，减少磁盘文件的频繁写</strong></p><ul><li>优点<ul><li>数据丢失的少，基本保证了每一条写命令所缓存的数据都有可重现的痕迹</li><li>如果当前 AOF 文件膨胀的过大，会有 rewrite 机制，即 Redis 会将写命令进行整合，删除一些过程数据</li></ul></li><li>缺点<ul><li>文件相对来说比较大</li><li>由于会记录每一次的写命令，所以会对写操作有一些影响</li><li>灾难恢复速度慢，因为如果要恢复数据，必须一条一条的执行所记录的写操作</li></ul></li></ul><h3 id=3-备份和恢复策略>3. 备份和恢复策略</h3><p>可以基于 redis 主从架构，redis master 节点对外读写，然后将数据异步的同步给 redis slaver 节点</p><p>master 节点采用 AOF 持久化策略保证数据的稳定性，能够减少数据的丢失</p><p>slaver 节点采用 RDB 持久化策略保证数据的完整性，能够在灾难过后迅速恢复数据</p><p>两种持久化策略结合使用，RDB 保证冷备，AOF 保证数据丢失少，灾后基于 RDB 迅速恢复部分数据，再基于 AOF 进行剩余缺失数据的补充</p><h2 id=八使用缓存会出现的问题>八、使用缓存会出现的问题</h2><h3 id=1-缓存经典三大场景>1. 缓存经典三大场景</h3><ul><li><p>缓存雪崩</p><ul><li><p>场景</p><p>数据缓存系统宕机或者大量热点 key 在同一时刻失效，导致大量请求瞬间同时打在数据库上，从而引起数据库承载压力瞬间过大</p></li><li><p>解决方案</p><ol><li>采用二级缓存策略，保证在即使缓存雪崩的情况下，内存级缓存能够保护数据库</li><li>缓存数据过期时间设置为随机，防止大量 key 同时过期失效</li><li>设置热点 key 永不过期</li><li>如果 redis 是分布式集群部署，则将热点数据均匀分散到各个实例上，并使用<code>主从+哨兵</code>或者<code>redis cluster</code>保证高可用</li><li>雪崩过后尽快采用持久化机制进行数据恢复</li></ol></li></ul></li><li><p>缓存穿透</p><ul><li><p>场景</p><p>请求要查询的 key 在缓存和数据库中都不存在，通常情况下是恶意攻击，这种请求方式会给数据库不断施压</p></li><li><p>解决方案</p><ol><li>接口处增加入参校验，对于不合法的入参直接拒绝访问</li><li>对于缓存和数据库中都不存在的数据，可以在 redis 中放一个默认值，设置短一些的过期时间，可以防止攻击者反复用同一个 key 攻击</li></ol></li></ul></li><li><p>缓存击穿</p><ul><li><p>场景</p><p>大量请求同时访问某个热点 key，而该热点 key 恰好在此时过期失效了，那么大量的请求将会同时访问数据库</p></li><li><p>解决方案</p><ol><li>设置热点 key 永不过期</li><li>业务逻辑中对在缓存中没有查询到数据的情况下，在数据库访问前加锁，保证在同一时刻，只有一个请求线程可以争抢到锁，进行数据库访问，查询到数据之后，将数据置入缓存，再释放锁，将其余线程再重放，先去缓存查询，发现有数据，直接获取缓存数据后返回</li></ol></li></ul></li></ul><h3 id=2-双写一致性问题>2. 双写一致性问题</h3><blockquote><p>引入缓存后，虽然能够提升系统性能，使系统更好的承载高并发的挑战，但是如果数据库中的数据发生的变更，则需要保证缓存的数据也能在下次访问的时候不再是之前的老数据，这就是需要考虑的<strong>缓存数据库双写一致性问题</strong>。</p></blockquote><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/image-20220324225835260.png data-srcset="../images/image-20220324225835260.png, ../images/image-20220324225835260.png 1.5x, ../images/image-20220324225835260.png 2x" data-sizes=auto alt=../images/image-20220324225835260.png title=image-20220324225835260></p><p>一般情况下，在数据访问时，首先查询缓存数据，如果缓存中没有查到，则查询数据库，之后再将数据库中查询到的数据放入缓存，在更新数据的时候，先删除缓存，再更新数据库，下一次的查询自然会重新去数据库中提取数据放入缓存。这里必须要将缓存删除，如果是更新缓存的话，则会出现<strong>缓存数据库双写一致性问题</strong>。</p><p>但是在极端情况下，以上方案还是会出现问题，比如在缓存删除之后，准备更新数据库之前，此时并发了一个读请求，这个读请求会去缓存中查不到数据，进而访问数据库进行数据查询，之后把查询到的数据再次放入缓存。</p><p>解决方式是将数据库与缓存的读写串行化，可以构造一个内存队列，对当前读写请求进行排队，有序从队列中取出请求，如果是写请求则先删除缓存再更新数据库，而读请求在此时总是还在队列中等待线程消费。</p><h3 id=3-redis-并发竞争问题>3. Redis 并发竞争问题</h3><blockquote><p>多个 redis 客户端同时写 key 导致顺序错乱。</p></blockquote><p>可以使用分布式锁，结合时间戳解决。分布式锁保证了同一时刻只有一个服务实例写 key；而时间戳则保证了下一次修改的版本是更新的</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-01-12</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/%E7%BC%93%E5%AD%98/>缓存</a>,&nbsp;<a href=/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/>中间件</a>,&nbsp;<a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/>分布式系统</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/branch-helper-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/ class=prev rel=prev title="Branch Helper 使用说明"><i class="fas fa-angle-left fa-fw"></i>Branch Helper 使用说明</a>
<a href=/redis%E9%AB%98%E5%8F%AF%E7%94%A8/ class=next rel=next title="02_Redis 高可用">02_Redis 高可用<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>yiwenup</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/twemoji@13.0.0/dist/twemoji.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:0},comment:{},lightGallery:{actualSize:!1,exThumbImage:"data-thumbnail",hideBarsDelay:2e3,selector:".lightgallery",speed:400,thumbContHeight:80,thumbWidth:80,thumbnail:!0},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},twemoji:!0}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>