---
title: "数据库路由中间件"
date: 2022-04-05T19:12:32+08:00
categories: ["工具集"]
tags: ["Spring","Mybatis","中间件"]
draft: false
code:
  copy: true
toc:
  enable: true
---

基于 Mybatis + Spring 扩展的数据库路由中间件

<!--more-->

## 一、分库分表

### 1. 为什么要分库分表

当业务体量较大，数据增量明显加快的适合，此时所有的数据都在同一个库的同一张表存储时，势必会给数据库带来压力，那么此时就需要进行分库分表。

**分库分表不一定是同时需要，有可能分库但不分表，也有可能分表但不分库。**目的是一致的，就是为了减小数据库的压力。

### 2. 如何分库分表

- 垂直拆分（分库）

  > 指按照业务将表进行分类，分布到不同的数据库上，这样也就将数据的压力分担到不同的库上面。最终一个数据库由很多表的构成，每个表对应着不同的业务，也就是专库专用。

- 水平拆分（分表）

  > 如果垂直拆分后遇到单机瓶颈，可以使用水平拆分。相对于垂直拆分的区别是：垂直拆分是把不同的表拆到不同的数据库中，而水平拆分是把同一个表拆到不同的数据库中。

## 二、需求说明

### 1. 需求中间件的目标

能够根据路由策略动态切换数据源。此处需要使用到`AOP`，在需要数据库路由的方法上做好标记，便于分库分表的逻辑处理；为了能决定当前数据将会落在哪个数据库的哪张表上，此处会引入`寻址操作`，同时还需要保证数据能均匀的落在不同的数据库上，所以会有`数据散列`的引入。

综上，所设计的知识点包含：

- AOP
- 数据源切换
- 散列算法
- 哈希寻址
- ThreadLocal

## 三、设计与实现

![image-20220405224435433](../images/image-20220405224435433.png)

> 约定内容：
>
> 1. 数据库命名按：数据库名称 + 0x。譬如 sample_01
> 2. 表名称按：表名称 + 0x。譬如 demo_01
> 3. 数据库名称以及表名称后面的数值，即 dbIdx 和 tbIdx，用以表示数据库和表的全局索引

- 在服务启动的时候，读取数据源配置，将数据源配置载入内存，加载所有动态数据源，数据源：**db+dbIdx**
- 在执行到 DAO 层方法时候，如果当前方法打了注解 `@DBRouter(key = "userId")`，则会进入 AOP 切面
- 在 AOP 切面中，主要做的事情就是提取方法参数中，对应注解 key 的键的值
- 获取到 key 对应的值后，根据路由计算策略，计算出 dbIdx 和 tbIdx，并将 dbIdx 与 tbIdx 放入 `ThreadLocal`
- 默认的路由计算策略参考 HashMap 的 key 哈希索引计算方式
- 之后基于 Mybatis Plugin 机制的扩展，解析当前方法的原生 SQL，提取`ThreadLocal`中的`tbIdx`，替换原生 SQL 中所查询的表，动态拼接表名为**表名+tbIdx**
- 最终 Mybatis 底层执行的时候会 lookup 数据源，匹配到**db+dbIdx**的数据库，执行SQL
